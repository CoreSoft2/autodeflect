#!/bin/bash
# {{no_edit_template}}
# {{no_edit_template}}
# {{no_edit_template}}
# {{no_edit_template}}
# ./autobrains_update.sh -i --force will update this file from template
# or if autobrains_update.sh is broken
# rm autobrains_update.sh
# ansible-playbook {{playbook_dir}}/site.yml -l controller --tags init
# {{no_edit_template}}
# {{no_edit_template}}
# {{no_edit_template}}
# {{no_edit_template}}
# {{no_edit_template}}

## This will be the loop variable DNETS 
{% set dnetspace = joiner(" ") %}
DNETS='{% for dnet in dnets %}{{dnetspace()}}{{dnet}}{% endfor %}'

EMAIL_NOTIFY='{{autobrains_config["email_notify"]}}'
EMAIL_KEY_ID='{{autobrains_config["email_key_id"]}}'
LOGDIR='{{autobrains_config["log_dir"]}}'

CUR_DIR="$(pwd)"
LOCK_PREFIX=".lock_autobrains-"
MAINTENANCE_LOCK='.maint_lock-'
AW_LASTRUN_FILE=".aw_lastrun"

{% set bpspace = joiner(" ") %}
{% if autobrains_bypasses is defined and autobrains_bypasses %}
BYPASS_FILES="{% for bypass in autobrains_bypasses %}{{bpspace()}}{{bypass}}{% endfor %}" 
{% endif %}

##########
## SETUP 
ECHO_SEPARATOR='\n#################################\n\t##\t##\n#################################\n'
DATE=$(date +%Y%m%d%H%M%S)
SKIP_UPDATE=0
NOTIFY_CONTENT=''
unset OVERRIDECHECKED INITAU NOCLIENT NOSPIN DEBUG STOP THEREST FORCE YES NO MOST MAINT_BYPASS MAINT CHANGED NEWCLIENTS_YML 


# set associative arrays
declare -A REMAP_TOUCHED
declare -A SKIPPED_INSTALL
for d in $DNETS; do
 REMAP_TOUCHED[$d]=1
 SKIPPED_INSTALL[$d]=1
done

if [ -n "$SUDO_USER" ] ; then
  UNAME=$SUDO_USER ; else
  UNAME=$(id -nu)
fi

############
## FUNCTIONS

function autobrains_help() {
HELP=$(cat <<EOF

-h|--help	Display this help and exit.

-m|--maint	Put $0 in maintenance mode.
		so it will need -b|--bypass
		to run.

-b|--bypass	Used to run when in maintenance
		mode.

-y|--yes	Alway answer yes to prompts.

-n|--n		Always answer no to prompts.

-d|--debug	Run in debug mode. More output
		printed to screen.

-s|--nospin	Do not use spinner while waiting
		for action to finish.

-i|--init	Rebuild this file and exit. Any
		temporary changes will be lost.

-c|--noclient	Do not download a new client.yml

--most		Run most local tasks. Mainly
		runs everything needed to update
		configuration to be pushed to
		the edges.

--all		Runs all tasks.

--force		Needed to get by some dangerous
		options. You will be prompted to
		include this option to force anyway.

Some useful options:

$0 --most -n
			This will update configuration but
			not install. You can then later run
			$0 and answer n for running for
			running rebuild options but y on
			checking for configurations updates.

$0 --most -y --force
			Run most local configuration and install.
			This is dangerous but will be the future
			for a automated update.
EOF
)

echo "$HELP" | less -EXR
}


# set the encrypted mailer routine
function notify() {
NOTE_FILE=$1
  gpg --homedir /root/.gnupg/ -e -a -r $EMAIL_KEY_ID | mailx -s "$UNAME updated w/ autobrains @ $DATE" ${EMAIL_NOTIFY} 
}

function notify_store() {
NOTE_FILE=$1
local NOTIFY_CONTENT="$UNAME updated $NOTE_FILE @ $DATE $(cat)" 

echo "$NOTIFY_CONTENT" >> ${LOCK_PREFIX}${UNAME}
}

function lock() {
ls -1 ${LOCK_PREFIX-}* > /dev/null 2>&1
RT=$?
if [ $RT -eq 0 ]; then 
  echo "\"$(ls -x ${LOCK_PREFIX-}* | sed s/${LOCK_PREFIX-}//g)\" is currently running this script. If not remove $(ls -x ${LOCK_PREFIX-}*)"
  exit
else
 touch ${LOCK_PREFIX-}$UNAME || echo -e "Could not write $(pwd)/${LOCK_PREFIX-}$UNAME\n\n"
fi
}

function maint_lock() {
if [ -n "$MAINT_BYPASS" ]; then
  if [ -n "$MAINT" ]; then
    echo "Can not set maintenance mode while trying to bypass. Exiting."
    exit
  else
    echo "Using maintenance bypass ....."
    return
  fi
fi
ls -1 ${MAINTENANCE_LOCK-}* > /dev/null 2>&1
RT=$?
if [ $RT -eq 0 ]; then
  echo -e "$(ls -x ${MAINTENANCE_LOCK-}* | sed s/${MAINTENANCE_LOCK-}//g) put in maintenance mode.\nRemove file "$(ls -x ${MAINTENANCE_LOCK-}*)" when done.\nUse $0 -b or $0 --bypass to bypass and run anyway."
  exit
fi

if [ -n "$MAINT" ]; then
  touch ${MAINTENANCE_LOCK-}$UNAME || echo -e "Could not write $(pwd)/${MAINTENANCE_LOCK-}$UNAME\n\n"
  echo "Maintenance mode is now enabled. Use $0 -b or $0 --bypass"
  exit
fi
}

function yorn() {
if [ -n "$YES" ]; then
  yn='y'
  $2
elif [ -n "$NO" ]; then
  yn='n'
  return
else
  while true; do
    read -p "$1 (y/n)? " yn
    case $yn in
      [Yy]* ) $2; break;;
      [Nn]* ) break;;
          * ) echo "Please answer y or n.";;
      esac
  done
fi
echo
}

function awstatsorn() {
if [ -n "$YES" ]; then
  yn='y'
  $2
elif [ -n "$NO" ]; then
  yn='n'
  return
else
  while true; do
    read -p "$1 (awstats/n)? " yn
    case $yn in
      [awstats]* ) $2; date > {{playbook_dir}}/$AW_LASTRUN_FILE ; break;;
      [Nn]* ) break;;
         * ) echo "Please answer awstats or n.";;
    esac
  done
fi
echo
}

function fetch_clients_yml() {
  curl -k -H "Host: {{autobrains_config["dashadmin_host"]}}" {{autobrains_config["dash_proxy"]}}{{autobrains_config["clients_yml_url"]}} > {{playbook_dir}}/clients.yml-revisions/clients.yml-${DATE} 2> /dev/null
   # Do this here incase clients.yml does not exist or is broken
  rm {{playbook_dir}}/clients.yml
  ln -s clients.yml-revisions/clients.yml-${DATE} clients.yml

  if diff {{playbook_dir}}/clients.yml-revisions/clients.yml-last_used {{playbook_dir}}/clients.yml-revisions/clients.yml-${DATE} >/dev/null 2>&1 ; then
    echo -e "No differences found from dashboard\nsince last completed run."
  else
    echo -e "Differences found from dashboard\nsince last completed autobrains run."
    echo -e $ECHO_SEPARATOR
    diff -U 5 {{playbook_dir}}/clients.yml-revisions/clients.yml-last_used {{playbook_dir}}/clients.yml-revisions/clients.yml-${DATE}
  NEWCLIENTS_YML=0
  fi
}

function install_file {
# File from Ansible
NEW_FILE=$1
# File in .../deflect/
OLD_FILE=$2

# Directory in .../deflect/
DIR=${OLD_FILE%/*}
# File name, same as basename
FILE=${OLD_FILE##*/}

[ -d ${DIR}/old ] || mkdir ${DIR}/old || ( echo "error creating old directory -quitting" && exit )
if [ -f ${OLD_FILE} ] ; then
  if [ -z "$YES" ]; then
    echo "Anything you would like to say about this update?"
    read explanation
    test -z "$explanation" && echo "no explanation? naughty!"
  else
    explanation="Automode" 
  fi

  cp ${OLD_FILE} ${DIR}/old/${FILE}-${DATE}-${UNAME}
  cp ${NEW_FILE} ${OLD_FILE}
  [ -f ${DIR}/old/${FILE}-latest ] && rm ${DIR}/old/${FILE}-latest
  ( /bin/echo -e "$explanation\n${OLD_FILE}\n" ; diff -u ${DIR}/old/${FILE}-${DATE}-${UNAME} ${OLD_FILE} ) | tee ${LOGDIR}/${FILE}.${DATE} | notify_store ${OLD_FILE}
  cp ${DIR}/${FILE} ${DIR}/old/${FILE}-latest
else
  cp ${NEW_FILE} ${OLD_FILE}
  cp ${DIR}/${FILE} ${DIR}/old/${FILE}-latest
  if [ -z "$YES" ]; then
    echo "Anything you would like to say about this update?"
    read explanation
    test -z "$explanation" && echo "no explanation? naughty!"
  else
    explanation="Automode"  
  fi

  ( /bin/echo -e "$explanation\n${OLD_FILE}\n" ; echo "installed ${OLD_FILE}" ) | tee ${LOGDIR}/${FILE}.${DATE} | notify_store ${OLD_FILE}
fi
}

function remap_diff_loop {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  for i in {{ats_output}}$DNET/remap.d/*.config; do
    ls $i > /dev/null 2>&1
    RT=$?
    if [ "$RT" -gt 0 ]; then
      continue
    fi
    local test=$(match_bypass_file "$(basename $i)")
    if [ $test -gt 0 ]; then 
      echo -e "Bypassing file $(basename $i)" 
      continue
    fi
    DIFF_FILES="$ATS_DIR/conf/remap.d/$(basename $i) $i"
    diff -Ntu $DIFF_FILES
    RT=$?
    if [ $RT -eq 2 ]
    then
      echo "ERROR: There was something wrong with the diff command"
    elif [ $RT -eq 1 ]
    then
      yorn "Do you want to install this file" "install_file $i $ATS_DIR/conf/remap.d/$(basename $i)" 
      [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0 || REMAP_TOUCHED[$DNET]=0
      echo -e $ECHO_SEPARATOR 
  fi
    
done 
}

function banjax_diff_loop {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  for i in {{banjax_output}}$DNET/banjax.d/*.bconf; do
    ls $i > /dev/null 2>&1 
    RT=$?
    if [ "$RT" -gt 0 ]; then
      continue
    fi
    local test=$(match_bypass_file "$(basename $i)")
    if [ $test -gt 0 ]; then 
      echo -e "Bypassing file $(basename $i)" 
      continue
    fi
    DIFF_FILES="$ATS_DIR/conf/banjax/banjax.d/$(basename $i) $i"
    diff -Ntu $DIFF_FILES
    RT=$?
    if [ $RT -eq 2 ]
    then
      echo "ERROR: There was something wrong with the diff command"
    elif [ $RT -eq 1 ]
    then
      yorn "Do you want to install this file" "install_file $i $ATS_DIR/conf/banjax/banjax.d/$(basename $i)" 
      [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0 || REMAP_TOUCHED[$DNET]=0
      echo -e $ECHO_SEPARATOR 
  fi
    
done 
}

function zone_diff_loop {
  for i in {{bind_output}}$DNET/*.zone; do
    ls $i > /dev/null 2>&1 
    RT=$?
    if [ "$RT" -gt 0 ]; then
      continue
    fi
    local test=$(match_bypass_file "$(basename $i)")
    if [ $test -gt 0 ]; then 
      echo -e "Bypassing file $(basename $i)" 
      continue
    fi
    DIFF_FILES="{{autobrains_config["zone_files"]}}/$DNET/$(basename $i) $i"
    diff -Ntu $DIFF_FILES
    RT=$?
    if [ $RT -eq 2 ]
    then
      echo "ERROR: There was something wrong with the diff command"
    elif [ $RT -eq 1 ]
    then
      # Check if live zone file is active in another dnet
      local zone_conflict=0
      for d in $DNETS ; do
        if [ "$d" == "$DNET" ]; then
          continue
        else
          [ -f {{autobrains_config["zone_files"]}}/$d/$(basename $i) ] && echo -e "\n$(basename $i) exists in $d\nand you want to install to $DNET.\nThis is not aloud! Please fix this.\nexample:\n mv {{autobrains_config["zone_files"]}}/$d/$(basename $i) {{autobrains_config["zone_files"]}}/$DNET/$(basename $i)\nor\n rm {{autobrains_config["zone_files"]}}/$d/$(basename $i)\nBypassing install option.\n" && local zone_conflict=1 
        fi
      done
      if [ $zone_conflict -eq 1 ]; then
        read -t 30 -p "[Enter] to continue or will automatically in 30 seconds " 
      else
        yorn "Do you want to install this file" "install_file $i {{autobrains_config["zone_files"]}}/$DNET/$(basename $i)"
        [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0
        echo -e $ECHO_SEPARATOR
     fi
    fi 
done
}

function banjax_new_diff {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  local test=$(match_bypass_file banjax.conf)
    if [ $test -gt 0 ]; then
      echo "Bypassing file banjax.conf"
      return 
    fi
  diff -Ntu $ATS_DIR/conf/banjax/banjax.conf {{banjax_output}}$DNET/banjax.conf
  RT=$?
  if [ $RT -eq 2 ]
  then
    echo "ERROR: There was something wrong with the diff command"
  elif [ $RT -eq 1 ]
  then
    yorn "Do you want to install this file" "install_file {{banjax_output}}$DNET/banjax.conf $ATS_DIR/conf/banjax/banjax.conf"
    [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0 || REMAP_TOUCHED[$DNET]=0
    echo -e $ECHO_SEPARATOR
  fi
}

function logs_xml_diff {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  local test=$(match_bypass_file logs_xml.config)
    if [ $test -gt 0 ]; then
      echo "Bypassing file logs_xml.config"
      return 
    fi
  diff -Ntu $ATS_DIR/conf/logs_xml.config {{ats_output}}$DNET/logs_xml.config
  RT=$?
  if [ $RT -eq 2 ]
  then
    echo "ERROR: There was something wrong with the diff command"
  elif [ $RT -eq 1 ]
  then 
    yorn "Do you want to install this file" "install_file {{ats_output}}$DNET/logs_xml.config $ATS_DIR/conf/logs_xml.config" 
    [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0 || REMAP_TOUCHED[$DNET]=0
    echo -e $ECHO_SEPARATOR
  fi
}

function remap_diff {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  local test=$(match_bypass_file remap.config)
    if [ $test -gt 0 ]; then
      echo "Bypassing file remap.config"
      return 
    fi
  diff -Ntu $ATS_DIR/conf/remap.config {{ats_output}}$DNET/remap.config
  RT=$?
  if [ $RT -eq 2 ]
  then
    echo "ERROR: There was something wrong with the diff command"
  elif [ $RT -eq 1 ]
  then  
    yorn "Do you want to install this file" "install_file {{ats_output}}$DNET/remap.config $ATS_DIR/conf/remap.config"
    [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0 || REMAP_TOUCHED[$DNET]=0
    echo -e $ECHO_SEPARATOR
  fi 
}

function cache_diff {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  local test=$(match_bypass_file cache.config)
    if [ $test -gt 0 ]; then
      echo "Bypassing file cache.config"
      return 
    fi
  diff -Ntu $ATS_DIR/conf/cache.config {{ats_output}}$DNET/cache.config
  RT=$?
  if [ $RT -eq 2 ]
  then
    echo "ERROR: There was something wrong with the diff command"
  elif [ $RT -eq 1 ]
  then  
    yorn "Do you want to install this file" "install_file {{ats_output}}$DNET/cache.config $ATS_DIR/conf/cache.config"
    [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && SKIPPED_INSTALL[$DNET]=0 || REMAP_TOUCHED[$DNET]=0
    echo -e $ECHO_SEPARATOR
  fi 
}

function bind_local_templated_diff {
  local test=$(match_bypass_file named.conf.local.templated)
    if [ $test -gt 0 ]; then
      echo "Bypassing file named.conf.local.templated"
      return 
    fi
  diff -Ntu {{autobrains_config["loc_bind_confs"]}}/named.conf.local.templated {{bind_output}}bind/named.conf.local.templated
  RT=$?
  if [ $RT -eq 2 ]
  then
    echo "ERROR: There was something wrong with the diff command"
  elif [ $RT -eq 1 ]
  then
    yorn "Do you want to install this file" "install_file {{bind_output}}bind/named.conf.local.templated {{autobrains_config["loc_bind_confs"]}}/named.conf.local.templated"
    [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && mark_all_skipped 
    echo -e $ECHO_SEPARATOR
  fi
}
  
function all_diff {
for DNET in $DNETS; do
  banjax_new_diff
  banjax_diff_loop
  logs_xml_diff
  remap_diff
  remap_diff_loop
  cache_diff
  zone_diff_loop
done
  bind_local_templated_diff
}

function list_bypass_files {
for aa in $BYPASS_FILES; do
  echo $aa
done
}

function match_bypass_file {
local a=$1
local return=0
for i in $BYPASS_FILES; do
 if [ "${i}" = "${a}" ]; then
   local return=1
 fi
done
echo $return
} 

function ctrl_c() {
  echo -e "\n** CTRL-C **\nCleaning up." 
  [ ! -s "${LOCK_PREFIX-}$UNAME" ] || cat "${LOCK_PREFIX-}$UNAME" | notify
  rm ${LOCK_PREFIX-}$UNAME
  cd $CUR_DIR
  tput cnorm
  echo -e "\n\n\tFinished.\n\n"
  exit 
}

function finish() {
  [ ! -s "${LOCK_PREFIX-}$UNAME" ] || cat "${LOCK_PREFIX-}$UNAME" | notify
  rm ${LOCK_PREFIX-}$UNAME  2>/dev/null
  cd $CUR_DIR
  [ -n "$AUTODEFLECT_AGENT" ] && kill $AUTODEFLECT_AGENT && echo "killing ssh-agent (${AUTODEFLECT_AGENT})"
  exit
}

function dot_generated() {
  ATS_DIR="{{autobrains_config["deflect_dir"]}}/edges/$DNET{{autobrains_config["trafficserver_dir"]}}"
  date +%s > $ATS_DIR/conf/remap.d/.generated
  touch $ATS_DIR/conf/remap.config
  CHANGED=0
}

function cat_blacklist() {
  echo -e "The following are not included from\n{{autobrains_config["dashadmin_host"]}}\n## START BLACKLIST ##"
  curl -k -H "Host: {{autobrains_config["dashadmin_host"]}}" {{autobrains_config["dash_proxy"]}}{{autobrains_config["dash_blacklist_url"]}}
  echo -e "\n## END BLACKLIST ##"
}

function controller_update() {
  # Check to make sure override.yml does not have sites not in clients.yml
  check_override

  rm -rf {{ats_output}} {{banjax_output}} {{bind_output}} 
  if [ -n "$DEBUG" ] ; then
    ansible-playbook {{playbook_dir}}/site.yml -l controller
  else
    ansible-playbook {{playbook_dir}}/site.yml -l controller > /dev/null &
    spin $!
  fi
}

function awstats_update() {
  if [ -z "$OVERRIDECHECKED" ]; then
    check_override
  fi

  if [ -n "$DEBUG" ] ; then
    ansible-playbook {{playbook_dir}}/site.yml -l awstats
  else
    ansible-playbook {{playbook_dir}}/site.yml -l awstats > /dev/null &
    spin $!
  fi
}

function initau() {
  rm $0
  ansible-playbook {{playbook_dir}}/site.yml -l controller --tags init
}

function spin() {
# Expects PID to be sent
local pid=$1
local delay=0.1
tput civis
if [ -z "$NOSPIN" ] ; then
  while [ "$(ps p $pid o pid=)" ]; do
    for s in / - \\ \|; do
      printf "\r[ $s ] - Running";
      sleep $delay;
    done;
  done
  # We are done
  wait $pid
  local exitcode=$?
  tput cnorm
  printf "\r                              \r"
else
  echo "[ / ] - Running, please wait."
  wait $pid
  local exitcode=$?
  tput cnorm
fi

if [ $exitcode -ne 0 ] ; then
  echo "Something went wrong. Run again in debug mode."
  exit
fi
}

function check_override {
  local check=$(for n in $(grep '^  [a-zA-Z0-9]' override.yml) ; do grep $n clients.yml >> /dev/null || echo "${n%%:} not found in clients.yml. This needs fixed." ; done)

  if [ "$check" == "" ]; then
    OVERRIDECHECKED=0
    return
  else
    echo "$check"
    exit
  fi
}

{% raw %}
function get_nonlive_edge() {
# This will return 1 available nonlive edges 
# Also it will try 5 times until it gets atleast 1 or returns nothing
if [ $DNET ]; then
  count=5
  until [ $count -le 0 ]; do
    # This should return a array
    edge=($(edge_query --dnet $DNET --health pass -s out -m available -q --format flat 2> /dev/null | cut -d' ' -f1 | cut -d'.' -f1 | tr '\r\n' ' '))
    if [ "${#edge[@]}" -ge "1" ]; then
      count=0
    else
      let count-=1
      sleep 5
    fi
  done
  if [ "${#edge[@]}" -ge "1" ]; then
    rand=$[$RANDOM % ${#edge[@]}]
    echo "${edge[$rand]}"
  fi
fi
unset edge count rand
}
{% endraw %}

function run_deploy() {
declare -A DEPLOYED

# set up an ssh-agent if we don't already have one, and kill it after if we created
# it now
[ -z $SSH_AUTH_SOCK ] && eval `ssh-agent -s` && AUTODEFLECT_AGENT=$SSH_AGENT_PID 
COUNTER=0
while ! ssh-add -ls 2>&1 | grep `ssh-keygen -lf {{ autobrains_config["deploy_key_path"] }} 2>&1 | awk '{print $2}'` >/dev/null ; do 
  ssh-add {{ autobrains_config["deploy_key_path"] }}
  let COUNTER=COUNTER+1
  if [ $COUNTER -gt 4 ]; then
    echo "Error loading key. Can not continue"
    exit
  fi
done
unset COUNTER

for DNET in $DNETS; do
  # Set DEPLOYED to 1 by default
  DEPLOYED[$DNET]=1
  NONLIVESAFE=1
  if [ ${REMAP_TOUCHED[$DNET]} -eq 0 ]; then
    nonlive=$(get_nonlive_edge)
    if [ $nonlive ]; then
      echo "Test config on $nonlive"
      if [ -n "$DEBUG" ]; then
        local test_run=$({{autobrains_config["deflect_dir"]}}/scripts/deploy.sh -A $DNET -p ats -H $nonlive)
      else
        local test_run=$({{autobrains_config["deflect_dir"]}}/scripts/deploy.sh -A $DNET -p ats -H $nonlive 2> /dev/null | sed -n '/^\(!!!\|Via\)/{s/!!!\|NOW//g;p;}') 
      fi
      if echo "$test_run" | grep Via >/dev/null 2>&1; then 
        echo "Found Via header. Test config good"
        NONLIVESAFE=0
      fi
    fi

    if [ $NONLIVESAFE -eq 0 ]; then
      if [ -n "$DEBUG" ]; then
        {{autobrains_config["deflect_dir"]}}/scripts/deploy.sh -A $DNET -p ats -H ALL
      else
        {{autobrains_config["deflect_dir"]}}/scripts/deploy.sh -A $DNET -p ats -H ALL 2> /dev/null | sed -n '/^\(!!!\|Via\)/{s/!!!\|NOW//g;p;}' 
      fi
      # We set a variable array for this DNET has been deployed
      DEPLOYED[$DNET]=0
    else
      if [ "$nonlive" = '' ]; then
        echo "Could not find a test edge. Will not continue."
      else
        echo -e "Config not safe. No Via header found when\ndeployed to $nonlive. Will not continue."
      fi
    exit
    fi
  # We are here because no new config detected on the DNET
  else
    # We only need 'conftouch' if client.yml was different
    if [ -n "$NEWCLIENTS_YML" ] && [ ! ${SKIPPED_INSTALL[$DNET]} -eq 0 ]; then
      echo "Full deploy not needed. Running \"conftouch\" for \"$DNET\""
      if [ -n "$DEBUG" ]; then
        {{autobrains_config["deflect_dir"]}}/scripts/deploy.sh -A $DNET -p conftouch -H ALL
      else
        {{autobrains_config["deflect_dir"]}}/scripts/deploy.sh -A $DNET -p conftouch -H ALL 2> /dev/null | sed -n '/^\(!!!\|Via\)/{s/!!!\|NOW//g;p;}' 
      fi
    else
      echo "Do not need a deploy on \"$DNET\""
    fi
    # We set a variable array for this DNET has been deployed
    DEPLOYED[$DNET]=0
  fi
done
}

function mark_all_skipped() {
for d in $DNETS; do
 SKIPPED_INSTALL[$d]=0
done
}

#########
### MAIN

# Get us in the right directory
if [ "$(pwd)" != "{{playbook_dir}}" ]; then
  echo -e "Changing to {{playbook_dir}}\n"
  cd {{playbook_dir}} 2> /dev/null
  RT=$?
  if [ $RT -eq 1 ]; then
    echo "ERROR: Could not change to directory {{playbook_dir}}. Exiting"
    exit
  fi
fi

# Create a lock file that also contains content for notify email when exiting
lock

# Trap ctrl-c or exit so we unlock and clean up
trap ctrl_c INT
trap finish EXIT

while test $# -gt 0; do
case "$1" in
  -h|--help)
  autobrains_help
  STOP=0
  shift
  ;;
  --all)
  MOST=0
  THEREST=0
  shift
  ;;
  -c|--noclient)
  NOCLIENT=0
  shift
  ;;
  --most)
  MOST=0
  shift
  ;;
  -d|--debug)
  DEBUG=0
  shift
  ;;
  -y|--yes)
  if [ -n "$NO" ]; then
    echo "Illegal option -y|--yes and -n|--no"
    exit
  else
    YES=0
  fi
  shift
  ;;
  -n|--no)
  if [ -n "$YES" ]; then
    echo "Illegal options. -y|--yes and -n|--no can not be used together"
    exit
  else
    NO=0
  fi
  shift
  ;;
  -m|--maint)
  MAINT=0
  shift
  ;;
  -s|--nospin)
  NOSPIN=0
  shift
  ;;
  -b|--bypass)
  MAINT_BYPASS=0
  shift
  ;;
  -i|--init)
  INITAU=0
  shift
  ;;
  --force)
  FORCE=0
  shift
  ;;
  *)
  # unknown option
  echo "Unknown option $1"
  STOP=0
  shift
  ;;
esac
done

if [ -n "$STOP" ] || [ -n "$INITAU" ] ; then
  if [ -n "$INITAU" ] && [ -z "$FORCE" ] ; then
    echo "Option -i|--init must be used with --force"
  elif [ -n "$INITAU" ] && [ -n "$FORCE" ] ; then
    initau
  fi 
  
  exit
fi

if [ -n "$YES" ] && [ -z "$FORCE" ]; then
  echo "Option -y|--yes must be used with caution. Include --force option if you are sure"
  exit
fi

maint_lock

if [ -n "$MOST" ]; then
  export SKIP_UPDATE=1
else
  yorn "Run config rebuild options" "export SKIP_UPDATE=1"
  [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && mark_all_skipped 
fi


if [ $SKIP_UPDATE -gt 0 ]; then
  if [ -z "$NOCLIENT" ]; then
    if [ -n "$MOST" ]; then
      fetch_clients_yml
    else
      yorn "Download latest dashboard config" "fetch_clients_yml"
      cat_blacklist
    fi
  fi

  if [ -n "$MOST" ]; then
    controller_update
  else
    yorn "Update (controller) config" "controller_update"
    [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && mark_all_skipped 
    echo
  fi
  if [ -z "$MOST" ]; then
    AW_LASTRAN=$(cat {{playbook_dir}}/$AW_LASTRUN_FILE)
    echo "Awstats was last updated: $AW_LASTRAN"
    awstatsorn "Update (awstats) config" "awstats_update"
  elif [ -n "$THEREST" ] ; then
    awstats_update 
  fi
fi

if [ -n "$MOST" ]; then
  all_diff
else
  yorn "Check config changes (controller)" "all_diff"
  [ "$yn" = 'n' ] || [ "$yn" = 'N' ] && mark_all_skipped 
fi

for DNET in $DNETS; do
  if [ ${REMAP_TOUCHED[$DNET]} -eq 0 ]; then
    dot_generated
  fi
done

# Only show if ATS change installed or clients.yml was updated
if [ -n "$CHANGED" ] || [ -n "$NEWCLIENTS_YML" ]; then
  yorn "Deploy to network" "run_deploy"
else
  # Set this for the next statment
  yn='n'
fi

if [ "$yn" = 'n'  ] || [ "$yn" = 'N' ]; then 
echo
echo "Below are the best guessed details that"
echo "still needs to happen to complete."
echo
for DNET in $DNETS; do
  if [ ${REMAP_TOUCHED[$DNET]} -eq 0 ]; then
    echo "proxy config changes for \"$DNET\" detected"
    nonlive=$(get_nonlive_edge)
    if [ $nonlive ]; then
      echo "deploy.sh -A $DNET -p ats -H $nonlive"
    else
      echo "ERROR: deploy.sh -A $DNET -p ats -H **missing**"
    fi
    echo "deploy.sh -A $DNET -p ats -H ALL"
    echo
  else
    echo "No proxy config changes for \"$DNET\" detected"
    if [ -n "$NEWCLIENTS_YML" ] && [ ! ${SKIPPED_INSTALL[$DNET]} -eq 0 ]; then 
      echo "deploy.sh -A $DNET -p conftouch -H ALL"
      echo
    else
      if [ ${SKIPPED_INSTALL[$DNET]} -eq 0 ]; then
        echo -e "and conftouch not recommended when skipping any steps."
        echo
      else
        echo  "and conftouch not needed"
        echo
      fi
    fi
  fi
done
echo "\"edge_manage\" will pick up zone changes automatically."
fi

echo "Update dashadmin and redmine if needed."
echo

# We do this if everything went okay
if [ -n "$NEWCLIENTS_YML" ]; then
  cp {{playbook_dir}}/clients.yml-revisions/clients.yml-${DATE} {{playbook_dir}}/clients.yml-revisions/clients.yml-last_used
fi


finish
